import { RouteProps } from "found";
import React from "react";
import { graphql, GraphQLTaggedNode, RelayPaginationProp } from "react-relay";

import { QueueContainer_queue as QueueData } from "talk-admin/__generated__/QueueContainer_queue.graphql";
import { QueueContainer_settings as SettingsData } from "talk-admin/__generated__/QueueContainer_settings.graphql";
import { QueueContainerPaginationPendingQueryVariables } from "talk-admin/__generated__/QueueContainerPaginationPendingQuery.graphql";
import { IntersectionProvider } from "talk-framework/lib/intersection";
import { withPaginationContainer } from "talk-framework/lib/relay";

import LoadingQueue from "../components/LoadingQueue";
import Queue from "../components/Queue";

interface QueueContainerProps {
  queue: QueueData;
  settings: SettingsData;
  relay: RelayPaginationProp;
}

// TODO: (cvle) If this could be autogenerated..
type FragmentVariables = QueueContainerPaginationPendingQueryVariables;

// TODO: use generated types
const danglingLogic = (status: string) =>
  ["ACCEPTED", "REJECTED"].indexOf(status) >= 0;

abstract class QueueContainer extends React.Component<QueueContainerProps> {
  public state = {
    disableLoadMore: false,
  };

  public render() {
    const comments = this.props.queue.comments.edges.map(edge => edge.node);
    return (
      <IntersectionProvider>
        <Queue
          comments={comments}
          settings={this.props.settings}
          onLoadMore={this.loadMore}
          hasMore={this.props.relay.hasMore()}
          disableLoadMore={this.state.disableLoadMore}
          danglingLogic={danglingLogic}
          emptyMessage={this.getEmptyQueueMessage()}
        />
      </IntersectionProvider>
    );
  }

  protected abstract getEmptyQueueMessage(): string;

  private loadMore = () => {
    if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {
      return;
    }
    this.setState({ disableLoadMore: true });
    this.props.relay.loadMore(
      10, // Fetch the next 10 feed items
      error => {
        this.setState({ disableLoadMore: false });
        if (error) {
          // tslint:disable-next-line:no-console
          console.error(error);
        }
      }
    );
  };

  protected static createRouteConfig(
    component: React.ComponentType<QueueContainerProps>,
    queueQuery: GraphQLTaggedNode,
    paginationQuery: GraphQLTaggedNode
  ): RouteProps {
    const enhanced = (withPaginationContainer<
      QueueContainerProps,
      QueueContainerPaginationPendingQueryVariables,
      FragmentVariables
    >(
      {
        queue: graphql`
          fragment QueueContainer_queue on ModerationQueue
            @argumentDefinitions(
              count: { type: "Int!", defaultValue: 5 }
              cursor: { type: "Cursor" }
            ) {
            count
            comments(first: $count, after: $cursor)
              @connection(key: "Queue_comments") {
              edges {
                node {
                  id
                  ...ModerateCardContainer_comment
                }
              }
            }
          }
        `,
        settings: graphql`
          fragment QueueContainer_settings on Settings {
            ...ModerateCardContainer_settings
          }
        `,
      },
      {
        direction: "forward",
        getConnectionFromProps(props) {
          return props.queue && props.queue.comments;
        },
        // This is also the default implementation of `getFragmentVariables` if it isn't provided.
        getFragmentVariables(prevVars, totalCount) {
          return {
            ...prevVars,
            count: totalCount,
          };
        },
        getVariables(props, { count, cursor }, fragmentVariables) {
          return {
            count,
            cursor,
          };
        },
        query: paginationQuery,
      }
    )(component) as any);

    return {
      Component: enhanced,
      query: queueQuery,
      cacheConfig: { force: true },
      render: ({ Component, props }) => {
        const anyProps = props as any;
        if (Component && props) {
          const queue =
            anyProps.moderationQueues[Object.keys(anyProps.moderationQueues)[0]];
          return <Component queue={queue} settings={anyProps.settings} />;
        }
        return <LoadingQueue />;
      },
    };
  }
}

export class PendingQueueContainer extends QueueContainer {
  public static routeConfig = PendingQueueContainer.createRouteConfig();

  protected getEmptyQueueMessage(): string {
    return "Nicely done! There are no more pending comments to moderate.";
  }

  protected static createRouteConfig(): RouteProps {
    const queueQuery = graphql`
      query QueueContainerPendingQuery {
        moderationQueues {
          pending {
            ...QueueContainer_queue
          }
        }
        settings {
          ...QueueContainer_settings
        }
      }
    `;

    const paginationQuery = graphql`
      # Pagination query to be fetched upon calling 'loadMore'.
      # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
      query QueueContainerPaginationPendingQuery($count: Int!, $cursor: Cursor) {
        moderationQueues {
          pending {
            ...QueueContainer_queue @arguments(count: $count, cursor: $cursor)
          }
        }
      }
    `;

    return QueueContainer.createRouteConfig(PendingQueueContainer, queueQuery, paginationQuery);
  }
}

export class ReportedQueueContainer extends QueueContainer {
  public static routeConfig = ReportedQueueContainer.createRouteConfig();

  protected getEmptyQueueMessage(): string {
    return "Nicely done! There are no more reported comments to moderate.";
  }

  protected static createRouteConfig(): RouteProps {
    const queueQuery = graphql`
      query QueueContainerReportedQuery {
        moderationQueues {
          reported {
            ...QueueContainer_queue
          }
        }
        settings {
          ...QueueContainer_settings
        }
      }
    `;

    const paginationQuery = graphql`
      # Pagination query to be fetched upon calling 'loadMore'.
      # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
      query QueueContainerPaginationReportedQuery($count: Int!, $cursor: Cursor) {
        moderationQueues {
          reported {
            ...QueueContainer_queue @arguments(count: $count, cursor: $cursor)
          }
        }
      }
    `;

    return QueueContainer.createRouteConfig(PendingQueueContainer, queueQuery, paginationQuery);
  }
}

export class UnmoderatedQueueContainer extends QueueContainer {
  public static routeConfig = UnmoderatedQueueContainer.getRouteConfig();

  protected getEmptyQueueMessage(): string {
    return "Nicely done! All comments have been moderated.";
  }

  protected static getRouteConfig(): RouteProps {
    const queueQuery = graphql`
      query QueueContainerUnmoderatedQuery {
        moderationQueues {
          unmoderated {
            ...QueueContainer_queue
          }
        }
        settings {
          ...QueueContainer_settings
        }
      }
    `;

    const paginationQuery = graphql`
      # Pagination query to be fetched upon calling 'loadMore'.
      # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
      query QueueContainerPaginationUnmoderatedQuery(
        $count: Int!
        $cursor: Cursor
      ) {
        moderationQueues {
          unmoderated {
            ...QueueContainer_queue @arguments(count: $count, cursor: $cursor)
          }
        }
      }
    `;

    return QueueContainer.createRouteConfig(UnmoderatedQueueContainer, queueQuery, paginationQuery);
  }
}
